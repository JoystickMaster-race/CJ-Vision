import static org.apache.tools.ant.taskdefs.condition.Os.*
plugins {
	id "edu.wpi.first.GradleRIO" version "2020.3.2"
	id "google-test-test-suite"
	id "java-test-fixtures"
	id "groovy"
	id "cpp"
}
apply from: rootProject.file("CJ-Vision/common/libs/libs.gradle")

def framework_version = "2020.3.2" // main program version (minimum is 2020.3.2)
def stupid_lock = true // stupid people might try to regenerate the framework with their code still inside
project.ext.set("stupid_lock", stupid_lock)


def cj_vision_src = ["CJ-Vision/common/cpp" ,"CJ-Vision/version/$framework_version/cpp"]
def cj_vision_headers = ["CJ-Vision/common/include", "CJ-Vision/version/$framework_version/include"]

def coproc_vision_src = ["../Coproc/src/main/cpp"]
def coproc_vision_headers = ["../Coproc/src/main/include"]

// Deploying
deploy {
	targets {
		target('coprocessor') {
			directory = '/home/vision/'
			maxChannels = 10
			timeout = 3
			failOnMissing = true

			locations {
				ssh {
					address = "CJVision.local"
					user = 'vision'
					password = 'CJfrc'
					ipv6 = false
				}
			}
		}
	}

	artifacts {

		// Common properties
		all {
			targets << 'coprocessor'
		}

		// Deploy CJ Vision Library CPP
		fileTreeArtifact("libCpp") {
			directory = 'cjVisionLib/src/cpp'
			files = fileTree(dir: 'src/cpp')
		}

		// Deploy CJ Vision Headers
		fileTreeArtifact('cjVisionLibHEADERS') {
			directory = 'cjVisionLib/src/include'
			files = fileTree(dir: 'src/include')
		}

		// Deploy Resource Files (service files and config)
		fileTreeArtifact('VisionResources') {
			files = fileTree(dir: 'src/resources')
			postdeploy << {
				execute('sudo ln -sf $(pwd)/system/vision.service /etc/systemd/system')
				execute('sudo systemctl daemon-reload; sudo systemctl enable vision')

				if (project.hasProperty('stop')) {
					execute('sudo systemctl daemon-reload; sudo service vision stop; sudo service vision status')
				} else {
					execute('sudo systemctl daemon-reload; sudo service vision restart; sudo service vision status')
				}
			}

			postdeploy << {
				execute('sudo cp -n /etc/ssh/sshd_config /etc/ssh/sshd_config.old')
				execute('sudo cp $(pwd)/system/sshd_config /etc/ssh/sshd_config')
			}
		}

		// User deploy files
		if (file('../Coproc').isDirectory()) {
			fileTreeArtifact('UserProgram') {
				directory = 'UserProgram/main'
				files = fileTree(dir: '../Coproc/src/main')
			}
			fileTreeArtifact('UserDeploys') {
				directory = 'UserProgram/deploy'
				files = fileTree(dir: '../Coproc/src/deploy')
			}
		}

		// Deploy Makefile and run project
		fileArtifact('makeFileDeploy') {
			directory = 'cjVisionLib/src/'
			file = file('src/Makefile')
			predeploy << {
				execute('sudo systemctl stop vision || true')
			}

			postdeploy << {
				execute('make coprocessor')
				execute('chmod +x cjVision')
				execute('sudo systemctl restart vision ||true')
			}
		}
	}
}

// Local Building
model {
	components {
		cjVision(NativeExecutableSpec) {
			if (!isFamily(FAMILY_WINDOWS)) {
				return
			}
			
			targetPlatform wpi.platforms.desktop
			sources.cpp {   
				source {
					if (project.hasProperty("debugMode")) {
						srcDirs = assert cj_vision_src + lib_src
					} else {
						srcDirs = assert cj_vision_src + lib_src + coproc_vision_src
					}
					includes = ['**/*.cpp', '**/*.cc', '**/*.c']
				}

				exportedHeaders {
					if (project.hasProperty("debugMode")) {
						srcDirs = assert cj_vision_headers + lib_headers
					} else {
						srcDirs = assert cj_vision_headers + lib_headers + coproc_vision_headers
					}
				}
			}

			binaries.all {
				if (project.hasProperty("debugMode")) {
					cppCompiler.define 'DEBUG_CJ'
				}
			}

			wpi.deps.wpilib(it)
			wpi.deps.googleTest(it)
			wpi.deps.vendor.cpp(it)
		}
	}
}

[FAMILY_WINDOWS, FAMILY_UNIX, FAMILY_MAC].each { osName ->
	// Create Task
	tasks.create(osName) {
		description "OS is ${osName}"
		
		// Add condition to check operating system.
		onlyIf { isFamily(osName) }

		doLast {
			println "Execution Family: '${it.name}'"
		}
	}

	// Add task as dependency for the os task
	build.dependsOn(osName)
}

// Generate coprocessor file using framework version
task generateFramework {
	doLast {
		description "Generates framework for user. If the framework exists, it will override if forced to do so"

		// Configure for args
		def force = project.hasProperty("force") // force property

		if (!file("framework/$framework_version").isDirectory()) {
			ant.fail("[WARNING] <$framework_version> is not supported. Only supported frameworks are allowed")
		}

		// Generate framework
		if (force) {
			project.stupid_lock = false
		}

		if (!file("../Coproc").isDirectory()) {
			project.stupid_lock = false
		}

		if (project.stupid_lock) {
			ant.fail("[WARNING STUPID_LOCK ACTIVE] Old coproc might still be present. Run with `./gradlew generateFramework -Pforce` if you're sure")
		} else {
			description "Generate `Coproc` folder with version framework and files"
			println "Generating framework version <$f_version>"
			delete "../Coproc"
			copy {
				from "framework/$f_version/"
				into "../"
			}
		}
	}
}

task buildVision {
	description "Builds vision locally"
	doLast {
		exec {
			workingDir "src/"

			println "Building Vision Project..."
			if (project.hasProperty("debugMode")) {
				commandLine 'make', 'debug'
			} else {
				if (!file('../Coproc').isDirectory()) {
					println("'Coproc' folder not found one level up from build.gradle. Generate using './gradlew generateFramework'")
					ant.fail("`Coproc` folder not found")
				}
				commandLine 'make'
			}
		}
	}
}

// Run Vision locally
task runVisionUNIX(type:Exec) {
	description "Run Vision Locally with webcam to test"
	workingDir "src/build"
	commandLine './cjVision'
}

/** 
 *
 * task configuration
 *
 */
// Run buldVision when user runs ./gradlew build
if (isFamily(FAMILY_WINDOWS)) {
	task runVision(dependsOn: "simulateCjVisionDebugExecutable")
} else if (isFamily(FAMILY_UNIX) || isFamily(FAMILY_MAC)) {
	build.finalizedBy(buildVision)
	runVisionUNIX.dependsOn(buildVision)
	task runVision(dependsOn: "runVisionUNIX")
} else {
	ant.fail("Unknown Platform detected")
}

wrapper {
	gradleVersion = '6.0'
}